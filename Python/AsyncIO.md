# AsyncIO
```
비동기 프로그래밍을 위한 모듈이며 CPU 작업과 I/O를 병렬로 처리하게 해줍니다.
```

## 이벤트 루프 ?
```
이벤트 루프는 작업들을 하나씩 실행시키는 역할을 합니다.  
메인 스레드에서 실행된 작업이 특정한 데이터를 요청하고 응답을 기다려야 한다면(I/O 작업),  
이 작업은 이벤트 루프에 통제권을 넘겨줍니다. 통제권을 받은 이벤트 루프는 다음 작업을 실행하게 됩니다.  
그리고 응답을 받은 순서대로 멈췄던 부분부터 다시 통제권을 가지고 작업을 마무리합니다.

메인 스레드 -> Task(여러 코루틴) -> 첫 코루틴 실행 -> 응답을 기다려야하는 작업 ->  
이벤트 루프에 해당 작업을 맡기고 -> 다음 코루틴 실행 -> 응답이 마무리된 코루틴부터 작업을 다시 시작함
```

## AsyncIO는 스레딩에서의 문제점을 어떻게 해결하였는가
```
- CPU 컨텍스트 스위칭: asyncio 는 비동기이며 이벤트 루프를 사용한다.  
  이는 I/O를 대기하는 동안 애플리케이션이 컨텍스트 스위치를 관리할 수 있도록 한다. CPU 스위칭이 없다!

- 경쟁 조건(Race Conditions): asyncio 는 한 번에 오직 하나의 코루틴만 실행하며 정의된 지점에서만  
  스위칭이 일어나기 때문에, 코드는 경쟁 조건으로부터 안전하다.

- 데드락/라이브 잠금(Dead-Locks/Live-Locks): 경쟁 조건에 대해 걱정할 필요가 없기 때문에,   
  잠금을 사용할 필요가 없다. 이는 데드락으로부터 매우 안전하게 만들어준다.  
  만약 두 개의 코루틴이 서로를 깨워야(wake) 할 필요가 있을 경우엔 여전히 데드락이 발생할 가능성이 있지만,  
  이런 일을 해야할 경우는 매우 드물 것이다.

- 기아 상태(Resource Starvation): 모든 코루틴이 하나의 스레드에서 실행되고,  
  추가적인 소켓이나 메모리를 필요로하지 않기때문에, 되려 리소스가 부족하기가 힘들 것이다.  
  그러나 Asyncio 는 기본적인 스레드 풀인 “executor pool”을 하나 가지고 있다.  
  만약 매우 많은 일들을 하나의 “executor pool”에서 실행한다면, 여전히 리소스 부족에 대한 문제가 발생할 수 있다.  
  하지만, 매우 많은 실행 프로그램을 사용하는것은 안티 패턴이며, 아마 이런 일을 자주 하지는 않을 것이다.
```