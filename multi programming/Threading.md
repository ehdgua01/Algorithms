# 멀티 스레드, 비동기 프로그래밍

## 프로세스와 스레드의 비교

```
프로세스(Process)
- 프로세스는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말한다. 종종 스케줄링의 대상이 되는 작업(task)이라는 용어와 거의 같은 의미로 쓰인다. 여러 개의 프로세서를 사용하는 것을 멀티프로세싱이라고 하며 같은 시간에 여러 개의 프로그램을 띄우는 시분할 방식을 멀티태스킹이라고 한다. 프로세스 관리는 운영 체제의 중요한 부분이 되었다.

스레드(Thread)
- 스레드는 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 말한다. 일반적으로 한 프로그램은 하나의 스레드를 가지고 있지만, 프로그램 환경에 따라 둘 이상의 스레드를 동시에 실행할 수 있다. 이러한 실행 방식을 멀티스레드(multithread)라고 한다.
```

### 그린 스레드(Green Threads)

```
- 그린 스레드는 비동기 프로그래밍의 가장 기초이다. 그린 스레드는 스케쥴링을 하드웨어가 아닌 애플리케이션 코드가 대신 한다는 점을 제외하면, 일반 스레드와 비슷하다.
- 구현을 보면 이는 실제 스레드 대신 코루틴을 사용하며, 스케쥴링을 위해 코루틴들을 이벤트 루프위에서 실행한다.
- 일반 스레드와 유사함: 스레드를 이해하고 있는 사람들이 사용하기 좋음
- CPU 컨텍스트 스위칭 문제를 제외한 일반 스레드 프로그래밍이 가진 모든 문제점들을 가지고 있음

ex) Gevent
```

### 콜백 스타일의 비동기

```
- 콜백은 함수이며, 이는 “이 작업이 완료되면, 이 함수를 실행시켜줘”라는 의미이다. 이는 기본적으로 코드에 대한 “완료” 훅(hook)이다.
- 스레드 프로그램과 많은 부분이 다름
- 프로그래머는 스레드와 코루틴을 직접 볼 수 없음
- 콜백은 예외를 발생시키지 않음
- 콜백은 수집할 수 없음
- 콜백의 콜백은 복잡하며 디버깅이 어려움

ex) Tornado
```

## 멀티 프로세스의 문제점
```
멀티스레드 환경이 확산됨에 따라 전통적인 프로세스 관리 방식에도 변화가 필요해졌다. 예를 들어, fork 또는 exec와 같은 시스템 호출시에 어떻게 처리할 것인가 하는 문제가 대두된 것이다.

fork 문제: 어떤 프로세스 내의 스레드가 fork를 호출하면 모든 스레드를 가진 프로세스를 생성할 것인지, 아니면 fork를 요청한 스레드만 가진 프로세스를 생성할 것인지 하는 문제이다. 유닉스에서는 각각 2가지 버전의 fork를 지원하고 있다.

exec 문제: fork를 통해 모든 스레드를 복제하고 난 후, exec를 수행한다면 모든 스레드들이 초기화된다. 그렇다면 교체될 스레드를 복제하는 작업은 필요가 없기 때문에 애초에 fork를 요청한 스레드만을 복제했어야 한다. 한편, fork를 한 후에 exec를 수행하지 않는다면 모든 스레드를 복제할 필요가 있는 경우도 있다
```

### 멀티 스레드 프로그래밍에서 발생하는 문제들

```
경쟁상태(Race Condition)

- 둘 이상의 입력이나 조작이 동시에 일어나 의도하지 않은 결과를 가져오는 경우
- 파일 또는 변수와 같은 공유 자원을 접근하는 하나 또는 그 이상의 프로세스들의 다중 접근이 제대로 제어되지 않은 것을 말합니다.
- 프로세스들 끼리 하나의 자원을 갖기 위해 싸우는 것, 하나의 자원을 동시에 요청
```

```
라이브락(Livelock)

- 한 프로세스가 이미 자원을 점유한 상태에서 다른 프로세스가 그 자원을 사용하기 위해 무한정 대기상태에 빠지는 것을 라이브락이라 합니다.
- 지극히 정상적인 동작이지만 분명 문제가 있는 동작입니다.
```

```
교착상태(DeadLock)

- 프로세스들이 더 이상 진행을 못하고 영구적으로 블록되어 있는 상태로, 시스템 자원에 대한 경쟁 도중에 발생할 수도 있고 프로세스간의 통신 과정에서도 발생할 수 있습니다.
- 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로는 아무것도 완료되지 못하는 상태를 말합니다.
- A프로세스가 A자원을 점유하고 B프로세스가 B자원을 점유한 상태에서 A프로세스의 다음 작업으로 B자원이 필요하고 B프로세스의 다음 자원으로 A자원이 필요할 경우, 서로의 작업이 끝나기만을 기다리며 아무것도 실행되지 않는 상태라고 할 수 있습니다.
- 경쟁상태도 교착상태(DeadLock)의 종류 중 하나입니다.
```

```
교착상태 조건

- 상호배제(Mutual Exclusion): 한 순간에 한 프로세스만이 자원을 사용할 수 있다. 즉, 한 프로세스에 의해 점유된 자원을 다른 프로세스들이 접근할 수 없다.

- 점유대기(Hold and Wait): 이미 자원을 보유한 프로세스가 다른 자원을 요청하며 기다리고 있다.

- 비선점(No preemption): 프로세스에 의해 점유된 자원을 다른 프로세스가 강제적으로 빼앗을 수 없다.

- 환형대기(Circular Wait): 프로세스간에 닫힌 연결이 존재할 경우입니다. 블록된 프로세스가 자원을 점유하고 있는데 이 자원을 다른 프로세스가 원하며 대기하고 있는 상태입니다.

교착상태를 발생시킨다고해서 이 조건들이 잘못된 조건은 아닙니다.
예를 들면, 상호배제는 수행 결과의 일관성과 데이터베이스의 무결성을 위해 반드시 필요합니다. 
선점 또한 임의대로 수행되어서는 안됩니다. 특히, 데이터 자원이 연관되어 있는 경우 선점은 롤백 복구 기법의 지원이 있어야만 가능합니다.

- 프로세스가 다시 재수행 될 수 있도록 프로세스의 상태와 사용하던 자원의 상태를 안정적인 이전의 상태로 복원할 수 있어야 함을 의미.
- 환형대기의 경우 조건 1 ~ 3의 결과에 의해 발생하게 된다.
```